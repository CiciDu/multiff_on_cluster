# ------------------------------
# System & Utilities
# ------------------------------
import os

# ------------------------------
# Project-specific modules
# ------------------------------
from decision_making_analysis.decision_making import decision_making_utils
from decision_making_analysis import free_selection, replacement
from data_wrangling import further_processing_class

# ------------------------------
# Scientific & Data Libraries
# ------------------------------
import numpy as np
import pandas as pd
import matplotlib
from matplotlib import rc
import matplotlib.pyplot as plt

# ------------------------------
# Scikit-learn: Model Selection
# ------------------------------

# ------------------------------
# Scikit-learn: Metrics
# ------------------------------

# ------------------------------
# Scikit-learn: Models
# ------------------------------

# ------------------------------
# External Gradient Boosting Libraries (optional)
# ------------------------------

# ------------------------------
# Matplotlib & Display Settings
# ------------------------------
plt.rcParams["animation.html"] = "html5"
os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'
rc('animation', html='jshtml')
matplotlib.rcParams.update(matplotlib.rcParamsDefault)
matplotlib.rcParams['animation.embed_limit'] = 2**128
pd.set_option('display.float_format', lambda x: '%.5f' % x)
np.set_printoptions(suppress=True)


class DecisionMakingHelper(further_processing_class.FurtherProcessing):
    def __init__(self, raw_data_folder_path=None):
        super().__init__(raw_data_folder_path=raw_data_folder_path)

    def get_monkey_data(self, already_retrieved_ok=True, include_monkey_information=True, include_ff_dataframe=True, include_GUAT_data=False,
                        include_TAFT_data=False):
        self.extract_info_from_raw_data_folder_path(self.raw_data_folder_path)
        self.retrieve_or_make_monkey_data(include_monkey_information=include_monkey_information)

        if include_ff_dataframe:
            if (already_retrieved_ok is False) | ((getattr(self, 'ff_dataframe', None) is None)):
                self.make_or_retrieve_ff_dataframe(
                    exists_ok=True)
                self.ff_dataframe_visible = self.ff_dataframe.loc[self.ff_dataframe['visible'] == 1].copy(
                )

        if include_GUAT_data:
            if getattr(self, 'GUAT_trials_df', None) is None:
                if getattr(self, 'ff_dataframe', None) is None:
                    self.make_or_retrieve_ff_dataframe(
                        exists_ok=True)
                self.get_give_up_after_trying_info()

        if include_TAFT_data:
            if getattr(self, 'TAFT_trials_df', None) is None:
                if getattr(self, 'ff_dataframe', None) is None:
                    self.make_or_retrieve_ff_dataframe(
                        exists_ok=True)
                self.get_try_a_few_times_info()

        if include_ff_dataframe:
            self.cluster_around_target_indices = None
            self.PlotTrials_args = (self.monkey_information, self.ff_dataframe, self.ff_life_sorted, self.ff_real_position_sorted,
                                    self.ff_believed_position_sorted, self.cluster_around_target_indices, self.ff_caught_T_new)

    def retrieve_manual_anno(self):
        """
        Retrieves manually annotated data from a CSV file and processes it to match the format of the data
        generated by the `find_ff_caught` method. Specifically, it adds columns for the time of each annotation,
        the index of the corresponding target time bin, and the index of the caught firefly. It also checks that
        the annotations are sorted in increasing order of time and warns the user if they are not.

        Returns:
            None
        """
        # since we're still updating manual_anno, we store it in multiff_analysis
        self.manual_anno = pd.read_csv('multiff_analysis/manual_anno.csv')

        # get manually annotated data
        self.manual_anno['time'] = self.monkey_information['time'].loc[self.manual_anno.starting_point_index.values].values
        self.manual_anno['target_index'] = np.searchsorted(
            self.ff_caught_T_new, self.manual_anno['time'].values)
        self.manual_anno['ff_index'] = self.manual_anno['ff_index'].astype(int)
        self.manual_anno['target_index'] = self.manual_anno['target_index'].astype(
            int)

        # check if the point_index or time in self.manual_anno is strictly monotonously increasing
        initial_index = self.manual_anno.index
        self.manual_anno.sort_values(by="time", inplace=True)
        whether_the_same = self.manual_anno.index == initial_index
        # this should return no index; otherwise the point_index/time is not strictly monotonously increasing
        wrong_indices = np.where(whether_the_same == False)[0]
        if len(wrong_indices) > 0:
            print("Warning: the point_index/time in self.manual_anno is not strictly monotonously increasing! There might be some errors in the manual annotation!")
            print("The wrong indices are:", wrong_indices)

    def separate_manual_anno(self):
        '''
        manual_anno_trimmed: df, the manual_anno that has the first target and the last target removed
        free_selection_df: df, the part of manual_anno_trimmed_valid that can be categorized as free_selection
        replacement_df: df, the part of manual_anno_trimmed_valid that cannot be categorized as free_selection
        prior_to_replacement_df: df, the part of manual_anno_trimmed_valid that is one row prior to the rows in replacement_df
        non_chosen_df: df, the part of ff_dataframe that shares point_index with replacement_df but is not chosen by the monkey based on manual_anno
        '''

        self.manual_anno_trimmed = self.manual_anno[self.manual_anno.target_index !=
                                                    self.manual_anno.target_index.min()]
        self.manual_anno_trimmed = self.manual_anno_trimmed[self.manual_anno_trimmed.target_index !=
                                                            self.manual_anno_trimmed.target_index.min()]
        self.manual_anno_trimmed_valid = self.manual_anno_trimmed[
            self.manual_anno_trimmed['ff_index'] >= 0]

        free_selection = self.manual_anno_trimmed_valid.groupby(
            'target_index').first().reset_index()
        self.manual_anno_trimmed_invalid_index = self.manual_anno_trimmed[
            self.manual_anno_trimmed['ff_index'] < 0].index
        invalid_ff_indices_positions = np.where(np.array(self.manual_anno_trimmed.index.isin(
            self.manual_anno_trimmed_invalid_index)) == True)[0]
        # to make sure it doesn't go out of index
        invalid_ff_indices_positions = invalid_ff_indices_positions[invalid_ff_indices_positions < len(
            self.manual_anno_trimmed)-1]
        more_free_selection = self.manual_anno_trimmed.iloc[invalid_ff_indices_positions+1]
        self.free_selection_df = pd.concat(
            [free_selection, more_free_selection]).drop_duplicates()
        # On the other hand, all the ff after a negative value of ff_index can be considered as free_selection
        self.replacement_df = self.manual_anno_trimmed_valid[~self.manual_anno_trimmed_valid.starting_point_index.isin(
            self.free_selection_df.starting_point_index)]
        # find rows in manual_anno_trimmed_valid that are one row prior to the rows in replacement_ff
        replacement_df_positions = np.where(np.array(
            self.manual_anno_trimmed_valid.index.isin(self.replacement_df.index)) == True)[0]
        self.prior_to_replacement_df = self.manual_anno_trimmed_valid.iloc[
            replacement_df_positions-1]

        self.non_chosen_df = pd.DataFrame([])
        ff_dataframe_visible = self.ff_dataframe[self.ff_dataframe['visible'] == 1]
        for trial in range(self.manual_anno_trimmed.target_index.min()+1, self.manual_anno_trimmed.target_index.max()):
            ff_dataframe_subset = ff_dataframe_visible[ff_dataframe_visible['target_index'] == trial]
            unique_ff = ff_dataframe_subset.ff_index.unique()
            replacement_ff = self.replacement_df[self.replacement_df['target_index'] == trial].ff_index.unique(
            )
            free_selection_ff = self.free_selection_df[self.free_selection_df['target_index'] == trial].ff_index.unique(
            )
            # among all ff in obs, the non_chosen_ff will be those that are neither in replacement_ff nor in free_selection_ff
            non_chosen_ff = np.setdiff1d(unique_ff, replacement_ff)
            non_chosen_ff = np.setdiff1d(non_chosen_ff, free_selection_ff)
            self.non_chosen_df = pd.concat(
                [self.non_chosen_df, ff_dataframe_subset[ff_dataframe_subset['ff_index'].isin(non_chosen_ff)]])

        # see data span
        span_in_min = (self.manual_anno.loc[self.manual_anno.index.max(), 'time'].item(
        ) - self.manual_anno.loc[self.manual_anno.index.min(), 'time'].item())/60
        print("The span of the data is {} min".format(round(span_in_min, 2)))

    def determine_n_seconds_before_or_after_crossing_boundary(self, n_seconds_before_crossing_boundary=None, n_seconds_after_crossing_boundary=None):
        if n_seconds_before_crossing_boundary is None:
            n_seconds_before_crossing_boundary = max(
                0, self.time_range_of_trajectory[1])
        if n_seconds_after_crossing_boundary is None:
            n_seconds_after_crossing_boundary = max(
                0, - self.time_range_of_trajectory[0])
        return n_seconds_before_crossing_boundary, n_seconds_after_crossing_boundary

    def eliminate_crossing_boundary_cases(self, n_seconds_before_crossing_boundary=None, n_seconds_after_crossing_boundary=None):
        n_seconds_before_crossing_boundary, n_seconds_after_crossing_boundary = self.determine_n_seconds_before_or_after_crossing_boundary(
            n_seconds_before_crossing_boundary, n_seconds_after_crossing_boundary
        )

        crossing_boundary_time = self.monkey_information.loc[
            self.monkey_information['crossing_boundary'] == 1, 'time'].values

        input_time = self.replacement_df.time.values
        original_length = len(input_time)
        CB_indices, non_CB_indices, left_input_time = decision_making_utils.find_time_points_that_are_within_n_seconds_after_crossing_boundary(input_time, crossing_boundary_time, n_seconds_after_crossing_boundary=n_seconds_after_crossing_boundary,
                                                                                                                                               n_seconds_before_crossing_boundary=n_seconds_before_crossing_boundary)
        self.replacement_df = self.replacement_df.iloc[non_CB_indices]
        self.prior_to_replacement_df = self.prior_to_replacement_df.iloc[non_CB_indices]
        print("replacement_df:",
              self.replacement_df.shape[0], "out of", original_length, "rows remains")

        input_time = self.free_selection_df.time.values
        original_length = len(input_time)
        CB_indices, non_CB_indices, left_input_time = decision_making_utils.find_time_points_that_are_within_n_seconds_after_crossing_boundary(input_time, crossing_boundary_time, n_seconds_after_crossing_boundary=n_seconds_after_crossing_boundary,
                                                                                                                                               n_seconds_before_crossing_boundary=n_seconds_before_crossing_boundary)
        self.free_selection_df = self.free_selection_df.iloc[non_CB_indices]
        print("free_selection_df:",
              self.free_selection_df.shape[0], "out of", original_length, "rows remains")

        input_time = self.non_chosen_df.time.values
        original_length = len(input_time)
        CB_indices, non_CB_indices, left_input_time = decision_making_utils.find_time_points_that_are_within_n_seconds_after_crossing_boundary(input_time, crossing_boundary_time, n_seconds_after_crossing_boundary=n_seconds_after_crossing_boundary,
                                                                                                                                               n_seconds_before_crossing_boundary=n_seconds_before_crossing_boundary)
        self.non_chosen_df = self.non_chosen_df.iloc[non_CB_indices]
        print("non_chosen_df:",
              self.non_chosen_df.shape[0], "out of", original_length, "rows remains")

    def get_replacement_x_df(self, add_arc_info=False, add_current_curv_of_traj=False, curvature_df=None, curv_of_traj_df=None, replacement_inputs_format='old_plus_diff_between_old_and_new',
                             ff_attributes=['ff_distance', 'ff_angle', 'time_since_last_vis'], arc_info_to_add=['opt_arc_curv', 'curv_diff'],
                             non_chosen_ff_selection_criterion='ff_angle_boundary', ff_caught_T_new=None):
        '''
        changing_pursued_ff_data: df, containing the input features for both original and alternative ff
        changing_pursued_ff_data_diff: df, containing the difference between the input features for both original and alternative ff
        replacement_inputs_additional_info: df, containing the time and point_index for each row in changing_pursued_ff_data
        replacement_inputs_for_plotting: array, containing the input features for both original and alternative ff, for plotting
        replacement_inputs: array, containing the input features for both original and alternative ff, for machine learning
        replacement_labels: array, containing the labels for machine learning
        replacement_time: array, containing the time for each row in replacement_inputs
        replacement_point_index: array, containing the point_index for each row in replacement_inputs
        replacement_x_df: df, containing the input features for both original and alternative ff, for visualization
        '''

        self.num_ff_per_row = 2

        # replacement_inputs_format should be in ['diff_between_old_and_new', 'old_plus_diff_between_old_and_new', 'both_old_and_new']
        if replacement_inputs_format == 'old_plus_diff_between_old_and_new':
            add_old_values_to_diff_df = True
        else:
            add_old_values_to_diff_df = False

        self.changing_pursued_ff_data, self.changing_pursued_ff_data_diff, self.replacement_inputs_addition_info, self.replacement_inputs_for_plotting = replacement.organize_replacement_x_df(self.replacement_df, self.prior_to_replacement_df, self.non_chosen_df, self.manual_anno, self.ff_dataframe, self.monkey_information, self.ff_real_position_sorted, equal_sample_from_two_cases=True,
                                                                                                                                                                                               add_arc_info=add_arc_info, arc_info_to_add=arc_info_to_add, add_current_curv_of_traj=add_current_curv_of_traj, curvature_df=curvature_df, curv_of_traj_df=curv_of_traj_df, add_old_values_to_diff_df=add_old_values_to_diff_df, ff_attributes=ff_attributes, ff_caught_T_new=ff_caught_T_new,
                                                                                                                                                                                               non_chosen_ff_selection_criterion=non_chosen_ff_selection_criterion)
        self.replacement_time = self.replacement_inputs_addition_info['time'].values
        self.replacement_point_index = self.replacement_inputs_addition_info['point_index'].values.astype(
            int)
        # Note: replacement_inputs is used for visualization, not for machine learning
        if (replacement_inputs_format == 'old_plus_diff_between_old_and_new') or (replacement_inputs_format == 'diff_between_old_and_new'):
            replacement_x_df = self.changing_pursued_ff_data_diff.copy()
        elif replacement_inputs_format == 'both_old_and_new':
            replacement_x_df = self.changing_pursued_ff_data.copy()
        else:
            raise ValueError(
                "replacement_inputs_format can only be 'old_plus_diff_between_old_and_new', 'diff_between_old_and_new', or 'both_old_and_new'")

        self.replacement_inputs = replacement_x_df.drop(
            ['whether_changed'], axis=1).values
        self.replacement_labels = replacement_x_df['whether_changed'].values

    def get_free_selection_x(self, num_ff_per_row=5, select_every_nth_row=1, add_arc_info=False, arc_info_to_add=['opt_arc_curv', 'curv_diff'],
                             curvature_df=None, curv_of_traj_df=None, **kwargs):
        '''
        free_selection_x_df: df, the input features for machine learning
        free_selection_labels: array, the labels for machine learning
        cases_for_inspection: dict, the cases that are chosen for inspection
        chosen_rows_of_df: df, the rows of free_selection_df that are chosen for inspection
        sequence_of_obs_ff_indices: list, the sequence of observed ff indices
        '''

        self.num_ff_per_row = num_ff_per_row

        if select_every_nth_row > 1:
            self.free_selection_df_sample = self.free_selection_df.iloc[::select_every_nth_row]
        else:
            self.free_selection_df_sample = self.free_selection_df.copy()

        self.free_selection_x_df, self.free_selection_labels, self.cases_for_inspection, self.chosen_rows_of_df, self.sequence_of_obs_ff_indices, self.free_selection_x_df_for_plotting = free_selection.organize_free_selection_x(self.free_selection_df_sample, self.ff_dataframe, self.ff_real_position_sorted, self.monkey_information, ff_caught_T_new=self.ff_caught_T_new,
                                                                                                                                                                                                                                   only_select_n_ff_case=None, num_ff_per_row=num_ff_per_row, add_arc_info=add_arc_info, arc_info_to_add=arc_info_to_add, curvature_df=curvature_df, curv_of_traj_df=curv_of_traj_df, **kwargs)
        self.free_selection_x_df_for_plotting = self.free_selection_x_df_for_plotting.drop(
            columns=['ff_angle_boundary'], errors='ignore')
        self.free_selection_time = self.chosen_rows_of_df.time.values
        self.free_selection_point_index = self.chosen_rows_of_df.starting_point_index.values.astype(
            int)
        self.cases_for_inspection_obs = self.cases_for_inspection['cases_for_inspection_obs']
        self.non_chosen_rows_of_df = self.cases_for_inspection['non_chosen_rows_of_df']
